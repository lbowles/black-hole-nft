<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>BlackHole SVG</title>
  </head>

  <body>
    <div id="canvasContainer"></div>
    <script>
      const PIXELS_PER_SIDE = 28
      const PIXEL_SIZE = 10
      const CANVAS_SIZE = PIXELS_PER_SIDE * PIXEL_SIZE
      let BASE_HUE = 15

      function getPixelSVG(tokenId, pixelClass, x, y) {
        const baseSaturation = 90
        const lightnesses = [20, 55, 80]
        const hueIncrements = 20

        const blackHoleColors = [
          "black",
          `hsl(${BASE_HUE + hueIncrements}, ${baseSaturation}%, ${lightnesses[2]}%)`,
          `hsl(${BASE_HUE}, ${baseSaturation}%, ${lightnesses[1]}%)`,
          `hsl(${BASE_HUE - hueIncrements}, ${baseSaturation}%, ${lightnesses[0]}%)`,
        ]

        const perimiterColors = ["#852C27", "#741D27", "#8F5359", "#D1652C"]
        let fillColor = ""
        const randomIndex = Math.floor(Math.random() * 200)

        if (pixelClass === 0) {
          // Background + small chance of dim star
          fillColor = randomIndex <= 10 ? "#504940" : backgroundColors[randomIndex % backgroundColors.length]
        } else if (pixelClass === 1) {
          fillColor = "black"
        } else if (pixelClass > 1 && pixelClass <= 6) {
          // Black hole
          fillColor = blackHoleColors[pixelClass - 1]
        } else if (pixelClass === 7) {
          // Perimiter
          if (randomIndex < 20) {
            fillColor = perimiterColors[randomIndex % perimiterColors.length]
          } else {
            return ""
          }
        }

        return `<rect x="${x * PIXEL_SIZE}" y="${
          y * PIXEL_SIZE
        }" width="${PIXEL_SIZE}" height="${PIXEL_SIZE}" fill="${fillColor}"/>`
        // <text x="${x * PIXEL_SIZE + PIXEL_SIZE / 2}" y="${y * PIXEL_SIZE + PIXEL_SIZE / 2}"
        // text-anchor="middle" dominant-baseline="middle" fill="white" font-size="10" font-family="sans-serif">${pixelClass}</text>
        // `
      }

      // Javascript
      function createQuarterCanvas(size) {
        let edgeSVG = ""
        let insideSVG = ""
        const renderEndIndex = PIXELS_PER_SIDE / 2
        const renderStartIndex = renderEndIndex - size - 5
        const tokenId = 1
        for (let i = renderStartIndex; i <= renderEndIndex; i++) {
          for (let j = renderStartIndex; j <= renderEndIndex; j++) {
            const x = j - PIXELS_PER_SIDE / 2
            const y = i - PIXELS_PER_SIDE / 2
            const distance = Math.floor(Math.sqrt(x * x + y * y))

            if (distance <= size) {
              insideSVG = insideSVG.concat(getPixelSVG(tokenId, 1, j, i))
            } else if (distance <= size + 1) {
              edgeSVG = edgeSVG.concat(getPixelSVG(tokenId, 2, j, i))
            } else if (distance <= size + 2) {
              edgeSVG = edgeSVG.concat(getPixelSVG(tokenId, 3, j, i))
            } else if (distance <= size + 3) {
              edgeSVG = edgeSVG.concat(getPixelSVG(tokenId, 4, j, i))
            } else if (distance <= size + 4) {
              // pixelsSVG = pixelsSVG.concat(getPixelSVG(tokenId, 5, j, i))
            } else if (distance <= size + 5) {
              // pixelsSVG = pixelsSVG.concat(getPixelSVG(tokenId, 7, j, i))
            }
          }
        }

        return [edgeSVG, insideSVG]
      }

      function createSVG([edgeSVG, insideSVG], holeSize) {
        let svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${CANVAS_SIZE} ${CANVAS_SIZE}" width="${CANVAS_SIZE}" height="${CANVAS_SIZE}">`

        // Black background
        svg += `<rect x="0" y="0" width="${CANVAS_SIZE}" height="${CANVAS_SIZE}" fill="#000000"/>`

        for (let i = 0; i < 20; i++) {
          let x = Math.floor(Math.random() * PIXELS_PER_SIDE) * PIXEL_SIZE
          let y = Math.floor(Math.random() * PIXELS_PER_SIDE) * PIXEL_SIZE

          const maxLightness = 12
          const minLigtness = 5

          const fillLightness = Math.floor(Math.random() * (maxLightness - minLigtness)) + minLigtness
          const fillColor = `hsl(0, 0%, ${fillLightness}%)`

          const pixel = `<rect x="${x}" y="${y}" width="${PIXEL_SIZE}" height="${PIXEL_SIZE}" fill="${fillColor}">
                    </rect>`
          svg += pixel
        }

        const id = `base${BASE_HUE}`

        // Edge part
        let g = `<g id="${id}">`
        g += edgeSVG
        g += `</g>`
        svg += g

        // Repetitions
        svg += `<use href="#${id}" transform="scale(-1,1),translate(-${CANVAS_SIZE + PIXEL_SIZE},0)" />`
        svg += `<use href="#${id}" transform="scale(1,-1),translate(0,-${CANVAS_SIZE + PIXEL_SIZE})" />`
        svg += `<use href="#${id}" transform="scale(-1,-1),translate(-${CANVAS_SIZE + PIXEL_SIZE},-${
          CANVAS_SIZE + PIXEL_SIZE
        })" />`

        // Noise
        // TODO:
        // [ ] Start animated noise outside frame
        // [x] Order brighter pixels on top of darker pixels
        // [x] Speed up animation as it gets closer to center
        // [x] Black part of black hole should be on top
        const centerX = CANVAS_SIZE / 2 / PIXEL_SIZE
        const centerY = centerX
        const radius = holeSize + 6
        for (let i = 0; i < 20; i++) {
          let x = Math.floor(Math.random() * PIXELS_PER_SIDE)

          const discriminant = radius ** 2 - (x - centerX) ** 2
          let minY = 0
          let maxY = PIXELS_PER_SIDE
          if (discriminant > 0) {
            // Bottom edge to bottom canvas
            minY = Math.floor(Math.sqrt(discriminant) + centerY)
            maxY = PIXELS_PER_SIDE

            // Top canvas to top edge
            if (Math.random() > 0.5) {
              maxY = centerY * 2 - minY
              minY = 0
            }

            // Randomly add perimiter glow
            if (Math.random() > 0.5) {
              const fillColor = `hsl(${BASE_HUE - 10}, 50%, 20%)`
              const pixel = `<rect x="${x * PIXEL_SIZE}" y="${
                (minY === 0 ? maxY + 1 : minY - 1) * PIXEL_SIZE
              }" width="${PIXEL_SIZE}" height="${PIXEL_SIZE}" fill="${fillColor}">
                    </rect>`
              svg += pixel
            }
          }

          // Select a random value between minY and maxY
          x = x * PIXEL_SIZE
          const y = Math.floor(Math.random() * (maxY - minY) + minY) * PIXEL_SIZE

          const maxLightness = 30
          const minLigtness = 15

          const fillLightness = Math.floor(Math.random() * (maxLightness - minLigtness)) + minLigtness
          const fillColor = `hsl(0, 0%, ${fillLightness}%)`

          const animateDuration = Math.floor(((maxLightness - fillLightness) / maxLightness) ** 2 * 40) + 10
          const animationOffset = Math.random() * 2

          const transformAnimation = `<animate attributeName="x" from="${x}" to="${
            centerX * PIXEL_SIZE
          }" dur="${animateDuration}s" repeatCount="indefinite" begin="${animationOffset}s" calcMode="spline" keyTimes="0;1" keySplines="0.4 0 0.2 1" values="${x};${
            centerX * PIXEL_SIZE
          }" calcMode="spline" keyTimes="0;1" keySplines="0.4 0 0.2 1"/>
      <animate attributeName="y" from="${y}" to="${
            centerY * PIXEL_SIZE
          }" dur="${animateDuration}s" repeatCount="indefinite" begin="${animationOffset}s" calcMode="spline" keyTimes="0;1" keySplines="0.4 0 0.2 1" values="${y};${
            centerY * PIXEL_SIZE
          }" calcMode="spline" keyTimes="0;1" keySplines="0.4 0 0.2 1"/>`

          const pixel = `<rect x="${x}" y="${y}" width="${PIXEL_SIZE}" height="${PIXEL_SIZE}" fill="${fillColor}">
                    ${transformAnimation}
                    </rect>`
          svg += pixel
        }

        // Inside part
        let g2 = `<g id="i${id}">`
        g2 += insideSVG
        g2 += `</g>`
        svg += g2

        // Repetitions
        svg += `<use href="#i${id}" transform="scale(-1,1),translate(-${CANVAS_SIZE + PIXEL_SIZE},0)" />`
        svg += `<use href="#i${id}" transform="scale(1,-1),translate(0,-${CANVAS_SIZE + PIXEL_SIZE})" />`
        svg += `<use href="#i${id}" transform="scale(-1,-1),translate(-${CANVAS_SIZE + PIXEL_SIZE},-${
          CANVAS_SIZE + PIXEL_SIZE
        })" />`

        svg += `</svg>`
        return svg
      }

      const hues = [15, 20, 25, 30, 35, 250]

      for (let i = 0; i < 6; i++) {
        const level = i

        BASE_HUE = hues[level]

        const holeSize = PIXELS_PER_SIDE / 2 - (10 - level)

        const canvas = document.createElement("span")
        canvas.innerHTML = createSVG(createQuarterCanvas(holeSize), holeSize)
        document.getElementById("canvasContainer").appendChild(canvas)
      }
    </script>
  </body>
</html>
